#include <KellyEInk_15_SSD1683_BW.h>

KellyEInk_15_SSD1683_BW::KellyEInk_15_SSD1683_BW(int16_t busy, int16_t rst, int16_t dc, int16_t cs, int16_t clk, int16_t din): KellyEInk_42_SSD1683_BW_2BIT(busy, rst, dc, cs, clk, din) {
	displayWidth = 200;
	displayHeight = 200;
}

const unsigned char KellyEInk_15_SSD1683_BW::LUT_TABLE_LUT_WF_PARTIAL[159] PROGMEM = {
    0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0xF,0x0,0x0,0x0,0x0,0x0,0x1,
    0x1,0x1,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x22,0x22,0x22,0x22,0x22,0x22,0x0,0x0,0x0,
    0x02,0x17,0x41,0xB0,0x32,0x28,
};	

void KellyEInk_15_SSD1683_BW::displayInit(unsigned int newBitMode, bool partialMode) {	
	
	KellyEInk_42_SSD1683_BW_2BIT::displayInit(newBitMode, false);
	// displayReset();
	// readBusy();
	// sendCommand(0x12); //  soft reset
	// readBusy();

	if (partialMode) {
				
		sendCommand(0x32);
		for(int i=0; i<153; i++) {
			sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[i]));
		}

		sendCommand(0x3F);
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[153]));

		sendCommand(0x03);
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[154]));

		sendCommand(0x04);
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[155]));
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[156]));
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[157]));

		sendCommand(0x2c);
		sendData(pgm_read_byte(&LUT_TABLE_LUT_WF_PARTIAL[158]));

		sendCommand(0x37);  //  Write Register for Display Option, Ping-Pong for black/white mode

		sendData(0x00);  
		sendData(0x00);  
		sendData(0x00);  
		sendData(0x00); 
		sendData(0x00);  	
		sendData(0x40);  
		sendData(0x00);  
		sendData(0x00);   
		sendData(0x00);  
		sendData(0x00);

		sendCommand(0x3C);  // Border Waveform Control 
		sendData(0x80);  
	} 
}

void KellyEInk_15_SSD1683_BW::displayUpdate() {

	if (partialProcess) {

		//  Display Update settings
		sendCommand(0x22); 
		sendData(0xCF);

		// Begin Display Update Sequence
		sendCommand(0x20);

		delay(100);
		readBusy();
	} else {
		sendCommand(0x20);
		readBusy();
	}
}

/*

void KellyEInk_15_SSD1683_BW::spiBegin() {
	SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0));
	SPI.begin();
}

void KellyEInk_15_SSD1683_BW::displaySleep() {

	// we cant wakeup in other case, idk why they do this, but if you move it to sleep, it wont answer on commands and stuck until VCC wire on\off
	if (ENK_PIN_RST >= 0)  KellyEInk_42_SSD1683_BW_2BIT::displaySleep();
	else {
		Serial.println(F("[Sleep] fail - RST pin not available"));
	}
}



void KellyEInk_15_SSD1683_BW::display(const unsigned char *blackimage, const unsigned char *ryimage, bool update) {

  sendCommand(0x24);   //write RAM for black(0)/white (1)

  for (int i = 0; i < 5000; i++) {
    sendData(pgm_read_byte(&blackimage[i]));
  }	

		Serial.println(F("[display] KellyEInk_15_SSD1683_BW"));
  if (update) displayUpdate();
}

*/